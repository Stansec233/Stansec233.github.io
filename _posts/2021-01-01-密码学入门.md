---
layout: mypost
title: 密码学入门
categories: [密码学]
---
密码学（Cryptography）一般可分为古典密码学和现代密码学。

现多用于加密存储，加密传输(https)，身份验证(非对称加密, 公钥加密+hash)，数字签名，防篡改(hash)等。

# 简介

## 基础
**古典密码学**，作为一种实用性艺术存在，其编码和破译通常依赖于设计者和敌手的创造力与技巧，并没有对密码学原件进行清晰的定义。

主要有：

·单表替换加密（Monoalphabetic Cipher）

·多表替换加密（Polyalphabetic Cipher） 

·奇奇怪怪的加密方式

**现代密码学**，起源于20世纪中后期出现的大量相关理论，1949年香农（C.E.Shannon）发表了题为《保密系统的通信理论》的经典论文标志着现代密码学的开始。

主要有：

·对称加密（Symmetric Cryptography，以DES，AES，RC4 为代表）

·非对称加密（Asymmetric Cryptography，以 RSA，ElGamal，椭圆曲线加密为代表）

·哈希函数（Hash Function，以 MD5，SHA-1，SHA-512 等为代表）

·数字签名（Digital Signature，以 RSA 签名，ElGamal 签名，DSA 签名为代表）

>其中，对称加密体制主要分为两种方式：
分组密码（Block Cipher），又称为块密码。
序列密码（Stream Cipher），又称为流密码。

**攻击类型**通常分为以下四种：

·唯密文攻击 ：只拥有密文

·已知明文攻击 ：拥有密文与对应的明文

·选择明文攻击 ：拥有加密权限，能够对明文加密后获得相应密文

·选择密文攻击 ：拥有解密权限，能够对密文解密后获得相应明文

**安全目标主**要包括：

·机密性(confidentiality)

·完整性(integrity) 

·可用性(availability)
## 柯克霍夫原则
柯克霍夫原则（Kerckhoffs's principle）由奥古斯特·柯克霍夫在19世纪提出：

**密码系统中唯一需要保密的是密钥。**
>A cryptosystem should be secure even if everything about the system, except the key, is public knowledge.

即使密码系统的任何细节已为人悉知，只要密匙（key）未泄漏，它也应是安全的。

在此之前，密码界的主流理念是“隐晦式安全”（Security through obscurity）。Security through obscurity（or Security by Obscurity)理念主张对全部系统实行保密，从设计到执行，每个环节都保密。这种传统加密理念最大的问题在于操作的难度很大，随着系统的复杂程度提高，技术的发展，对每个环节都加密或保密越来越难实现。另外，一旦系统链条中的任何环节的秘密被泄露，整个系统的弱点就完全暴露了。

依据柯克霍夫原则，大多数民用保密都使用公开的算法， 但相对地，用于政府或军事机密的保密器通常也是保密的。

柯克霍夫为军用保密器所设计的这六个原则是：

·即使非数学上不可破解，系统也应在实质（实用）程度上无法破解。

·系统内不应含任何机密物，即使落入敌人手中也不会造成困扰。

·密匙必须易于沟通和记忆，而不须写下；且双方可以容易的改变密匙。

·系统应可以用于电讯。

·系统应可以携带，不应需要两个人或以上才能使用（应只要一个人就能使用）。

·系统应容易使用，不致让用户的脑力过分操劳，也无需记得长串的规则。

克劳德·艾尔伍德·香农有句近似的话「敌人知道系统」，称为香农公理。

布鲁斯·施奈尔将这个想法延伸，认为除了密码系统之外，任何保安系统都是这样：试图保密一些东西，都会制造了失败的根源。

埃里克·斯蒂芬·雷蒙则将它引伸到开放源代码软件，指软件设计不假设敌人会得到源代码，已经不可靠，因此，永无可信的封闭源码。反过来说，开放源码比封闭源码更安全。
## 一次性密码本
 一次性密码本（One Time Pad）由维纳（G.S.Vernam）于1917年提出，是古典密码学替换式（值位移）加密方法的终极形态。

OTP采用对称加密方式，使用了与明文等长的密文，使得所有字符的使用概率相等，密文完全不揭示任何明文信息，使得任何唯密文攻击无效。算法核心是将明文和一串随机的二进制进行XOR运算，这个随机的二进制数可以通过不断的抛掷硬币来产生（正面表示1，反面表示0），且异或的一个非常重要的特性就是可逆，A XOR B= C ，则 C XOR B = A ，那么通过原文和密钥异或得到的结果，可以通过将结果和密钥再次异或操作得到原文。

香农（C.E.Shannon）于1949年通过数学方法证明一次性密码本无法破译。一般来说只要通过暴力破解对密钥空间进行遍历，无论是什么密文理论上都能够被破译，但由于我们无法判断得到明文是不是正确的明文，相当于要在只知道明文长度的情况下构建明文，OTP是无条件安全的。

使用此算法进行加密通信的双方需要拥有完全一样的密钥数据，而在某些环境下，这种条件是无法实现的，因为要想让双方都拥有这个密钥，就意味着必须有一种足够安全的方式让双方共享或传递密钥数据，而如果有了这样的安全环境，也就不需要再使用一次性密钥了。所以一般来说通过物理方式传递密钥(比如亲手交给对方)才能实现一次性密钥的优势。

所以一次性密码本是一种几乎没有实用的密码，但是一次性密码本的思路却孕育出了流密码 。流密码使用的不是真正的随机比特序列，而是伪随机数生成器产生的比特序列。流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出较高强度的密码系统。
### 真实案例
#### 维诺那计划
一般地说来，按照一次性密码本来加密信息是一项很慢的并且工作量巨大的工序。

在1941年爆发的苏德战争使得加密信息的工作量突然大增，很可能是苏联密码制造部门为了赶得上进度而不得不偷懒复制了一部分一次性密码本。所以1946年维诺那计划成功破解部分信息并揭示了苏联间谍在美国华盛顿国务院、财政部、战略情报局、甚至白宫中的大批渗透。
#### PPTP协议

Windows NT采用点对点隧道协议（PPTP 协议）作为服务器与用户交互方式。

简单来说加密方式：

用户端：(m1+m2+m3...) ⊕ k

服务端：(m1+m2+m3...) ⊕ k

多个消息结合起来后采用密钥加密，看似没问题，但是最大的问题是，用户端与服务端使用的是相同的k加密，因此这就达成了一次性密码本多次使用的漏洞。

PPTP vpn认证过程为mschapv2，总key 长度为 2^56 x2 = 57bits，FPGA之类的专用硬件大概23小时内搞定。MPPE的128位session key是基于mschapv2的hash生成的，套了几次md4和sha1而已，如果获得了初始认证的key，如果对整个pptp vpn抓包了的话，可以推出后续的session key从而解密整个pptp vpn流量。所以说PPTP vpn缺乏forward secrecy，一旦key被破解就可以解密全部之前的流量，但是ipsec的ike握手用的是diffie hellman key exchange，每次随机产生的session key可以提高forward secrecy。
#### 802.11b 
![](http://standeblogtc.test.upcdn.net/1/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9DeXFxMXpYY21Ga1NKUXJGTGg1dG5qRjdqeFB6Mmo0ZndXQTh6aE9hbHhJS2VUeGwwOW9lZVloaHJvWllxUkRha2J0NjFkS3lTR2hpY2ljbU5Sc0JXazBBLzY0MA.png)

其中802.11b 协议加密方式：

![](http://standeblogtc.test.upcdn.net/1/20161001043444741.png)

m：明文   

CRC：校验码   

PRG：伪随机密钥流

明文消息由m和CRC组成，由PRG作为密码本加密，密文ciphetext前会放上IV（24位字符）。

每帧使用不同的密钥，具体方式是，将IV放在密文前面，每个数据包IV不同，于是每一个数据包后IV+1，然后服务器可以通过IV和Key推断出PRG。

问题在于24位的IV约为1600万，意思就是，每1600帧后密码本会有一次循环。这还不是最大的问题，最大的问题是每次重启后IV会回归0，并且每次IV+1的策略也使得新密码本变化不大。
#### RC4
RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变，它加解密使用相同的密钥，因此也属于对称加密算法，是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。

1987年被罗纳德·李维斯特开发出来，采用128位作为seed，密钥2048位，每个byte一循环，曾经的google的https也在使用。

弱点在于伪随机设计的有问题。第二字节出现0的概率是平均值的两倍，第三，四位的概率也不均匀。解决方法是丢掉前256位，从257位字节开始，使用第二个循环。另外，跑掉几个G的数据量后，出现（00）双字节的概率偏大。最后，每个key之间有一定的联系。

分布式代码管理网站Github从2015年1月5日将停止对RC4的支持，RC4作为一种老旧的验证和加密算法易于受到黑客攻击。这意味着，用户在使用Windows XP系统上的IE浏览器时将无法进入github.com网站。
#### CSS加密
CSS内容扰乱系统(Content Scrambling System) 是一种防止直接从盘片上复制视频文件的数据加密和鉴定方法。每个获得许可的人都能得到一把密钥，它从加密光盘上的密钥组成的母集中取出来。只要在以后的光盘上去除该密钥，许可就失效了。

CSS最初由Matsushita和东芝开发。每个CSS证书都有一把密钥，它是存储在每张CSS加密盘片上由400个密钥组成的母集中取出来的。 这样以后盘片上的密钥被移除，证书就无效了。CSS解密算法与驱动器单元交换密钥，以生成加密用的密钥。这一生成的密钥用来扰乱盘片密钥与影片密钥的交换。影片密钥用来解密盘片上数据。DVD播放机在解码和播放前，由CSS电路对数据进行解密。

破解：seed = 5 bytes = 40 bits，因为出口法规定，所以只能使用这个过短的密钥。另外，抛开上面一点，只需要2的17次方尝试就能解开，因为DVD文件均是.MPEG文件，前缀已知。
### 运动密码本
因为需要物理交换密码本，单次密码本执行起来非常困难，因此发明了运动密码本，选择一本普通的书，指定密钥为书中一段内容。

隐藏密码同上，没有复杂的算法，利用双方约定的方式提取公开的信息中的秘密信息。

# 常见编码与加密
## 常见编码
### ASCII编码
ASCII编码大致可以分作三部分组成：（参详http://www.asciima.com/ ）

第一部分是：ASCII非打印控制字符;

第二部分是：ASCII打印字符，也就是CTF中常用到的转换;

第三部分是：扩展ASCII打印字符
### Base64/32/16编码
Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是要64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因
### shellcode编码
shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。常常使用机器语言编写。可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。
### Quoted-printable 编码
它是多用途互联网邮件扩展（MIME) 一种实现方式。其中MIME是一个互联网标准，它扩展了电子邮件标准，致力于使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。目前http协议中，很多采用MIME框架。quoted-printable 就是说用一些可打印常用字符，表示一个字节（8位）中所有非打印字符方法。

任何一个8位的字节值可编码为3个字符：一个等号”=”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值.例如，ASCII码换页符（十进制值为12）可以表示为”=0C”, 等号”=”（十进制值为61）必须表示为”=3D”. 除了可打印ASCII字符与换行符以外，所有字符必须表示为这种格式。

所有可打印ASCII字符(十进制值的范围为33到126)可用ASCII字符编码来直接表示,但是等号”=”(十进制值为61)不可以这样直接表示.ASCII的水平制表符(tab)与空格符,十进制为9和32,如果不出现在行尾则可以用其ASCII字符编码直接表示。如果这两个字符出现在行尾，必须QP编码表示为”=09″ (tab)或”=20″(space)。

如果数据中包含有意义的行结束标志，必须转换为ASCII回车(CR)换行(LF)序列，既不能用原来的ASCII字符也不能用QP编码的”=”转义字符序列。 相反，如果字节值13与10有其它的不是行结束的含义，它们必须QP编码为=0D与=0A。

quoted-printable编码的数据的每行长度不能超过76个字符。为满足此要求又不改变被编码文本，在QP编码结果的每行末尾加上软换行(soft line break). 即在每行末尾加上一个”=”, 但并不会出现在解码得到的文本中。

例如：The quick brown fox jumps over the lazy dog 编码后结果是：

The=20quick=20brown=20fox=20jumps=20over=20the=20lazy=20dog
### XXencode编码
XXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。它所选择的可打印字符是：+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz，一共64个字符。跟base64打印字符相比，就是UUencode多一个“-” 字符，少一个”/” 字符。
###  UUencode编码
UUencode是一种二进制到文字的编码，最早在unix 邮件系统中使用，全称：Unix-to-Unix encoding，UUencode将输入文本以每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。
### URL编码
url编码又叫百分号编码，是统一资源定位(URL)编码方式。URL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。 

现在已经成为一种规范了，基本所有程序语言都有这种编码，如js：有encodeURI、encodeURIComponent，PHP有urlencode、urldecode等。编码方法很简单，在该字节ascii码的的16进制字符前面加%.如空格字符，ascii码是32，对应16进制是'20'，那么urlencode编码结果是:%20。
### Unicode编码
Unicode编码有四种编码方式：&#x [Hex];&# [Decimal];\U [Hex];\U+ [Hex]

一段通俗介绍：

很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。

开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作：

遇上0×10, 终端就换行；

遇上0×07, 终端就向人们嘟嘟叫；

遇上0x1b,打印机就打印反白的字，或者终端就用彩色显示字母。

他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做ANSI的”Ascii”编码（American Standard Code for Information Inter change，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。

后来，就像建造巴比伦塔一样，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！

等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉,规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做“GB2312“。GB2312 是对 ASCII 的中文扩展。

但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把GB2312没有用到的码位找出来老实不客气地用上。后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为GBK标准，GBK包括了GB2312的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 

中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：“一个汉字算两个英文字符！一个汉字算两个英文字符……”

因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的DBCS编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，像是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持BIG5编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？真是计算机的巴比伦塔命题啊！

正在这时，大天使加百列及时出现了——一个叫ISO（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。

unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是ISO就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。

这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。

unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。

unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到utf-8并不是直接的对应，而是要过一些算法和规则来转换。

总结一下：

中国人民通过对ASCII编码的中文扩充改造，产生了GB2312编码，可以表示6000多个常用汉字。汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。

中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把GBK编码扩充为GB18030编码。每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。

终于，有个叫ISO的组织看不下去了。他们一起创造了一种编码UNICODE，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有UNICODE这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。

UNICODE在网络传输中，出现了两个标准UTF-8和UTF-16，分别每次传输8个位和16个位。于是就会有人产生疑问，UTF-8既然能保存那么多文字、符号，为什么国内还有这么多使用GBK等编码的人？因为UTF-8等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。

### Escape/Unescape编码
Escape/Unescape加密解码/编码解码,又叫%u编码，采用UTF-16BE模式，Escape编码/加密,就是字符对应UTF-16,16进制表示方式前面加%u。Unescape解码/解密，就是去掉"%u"后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”。
### HTML实体编码
参考 http://www.w3school.com.cn/tags/html_ref_entities.html
### 敲击码
敲击码(Tap code)是一种以非常简单的方式对文本信息进行编码的方法。因该编码对信息通过使用一系列的点击声音来编码而命名，敲击码是基于5×5方格波利比奥斯方阵来实现的，不同点是是用K字母被整合到C中。
### 莫尔斯电码
摩尔斯电码(Morse Code)是由美国人萨缪尔·摩尔斯在1836年发明的一种时通时断的且通过不同的排列顺序来表达不同英文字母、数字和标点符号的信号代码。

摩尔斯电码除了能对字母数字编码以外还对一些标点符号，非英语字符进行了编码，而且还有一些特定意义的组合称为特殊符号，比如 ·-·-·-·-·- 表达的意思是调用信号，表示“我有消息发送”。
## 文本加密
文本加密可以将正常文本内容打乱为不可连读的文字或符号(汉字 数字 字母 音乐符号 国际音标 盲文 韩文 日文 傣文 彝文 箭头符号 花朵符号 俄文)，换行等格式信息也会被清除，达到加密的作用。在进行文本加密时可以设定一个密码，这样只有知道密码的人才能解密文本。密码可以是数字、字母和下划线，最多九位。
## 换位加密
### 栅栏密码
栅栏密码(Rail-fence Cipher)就是把要加密的明文分成N个一组，然后把每组的第1个字符组合，每组第2个字符组合...每组的第N(最后一个分组可能不足N个)个字符组合，最后把他们全部连接起来就是密文，这里以2栏栅栏加密为例。

明文： The quick brown fox jumps over the lazy dog

去空格： Thequickbrownfoxjumpsoverthelazydog

分组： Th eq ui ck br ow nf ox ju mp so ve rt he la zy do g

第一组： Teucbonojmsvrhlzdg

第二组： hqikrwfxupoeteayo

密文： Teucbonojmsvrhlzdghqikrwfxupoeteayo
### 曲路密码
曲路密码(Curve Cipher)是一种换位密码，需要事先双方约定密钥(也就是曲路路径)。

明文： The quick brown fox jumps over the lazy dog

![](http://standeblogtc.test.upcdn.net/1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-01-11%20153621.png)

密文： gesfc inpho dtmwu qoury zejre hbxva lookT
### 列移位密码
列移位密码(Columnar Transposition Cipher)是一种比较简单，易于实现的换位密码，通过一个简单的规则将明文打乱混合成密文。下面我们以明文 The quick brown fox jumps over the lazy dog，密钥 how are u为例：

填入5行7列表(事先约定填充的行列数，如果明文不能填充完表格可以约定使用某个字母进行填充，这里同上)

密钥： how are u

按how are u在字母表中的出现的先后顺序进行编号，我们就有a为1,e为2，h为3，o为4，r为5，u为6，w为7，所以先写出a列，其次e列，以此类推写出的结果便是密文：

![](http://standeblogtc.test.upcdn.net/1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-01-11%20154255.png)

密文： qoury inpho Tkool hbxva uwmtd cfseg erjez
##  替换加密
### 埃特巴什码
埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密。
### 凯撒密码
凯撒密码(Caesar Cipher或称恺撒加密、恺撒变换、变换加密、位移加密)是一种替换加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。
### ROT5/13/18/47
ROT5/13/18/47是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取。

ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。

ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。

ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。

ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码。
### 简单替换密码
简单换位密码(Simple Substitution Cipher)加密方式是以每个明文字母被与之唯一对应且不同的字母替换的方式实现的，它不同于恺撒密码，因为密码字母表的字母不是简单的移位，而是完全是混乱的。
### 希尔密码
希尔密码(Hill Cipher)是基于线性代数多重代换密码，由Lester S. Hill在1929年发明。每个字母转换成26进制数字：A=0, B=1, C=2...Z=25一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD26。

![](http://standeblogtc.test.upcdn.net/1/3333333.jpeg)

![](http://standeblogtc.test.upcdn.net/1/444444444.jpeg)
对于较长的二元矩阵（2×2的希尔密码）频率分析可能可能会有帮助，但是对于较短的密文分析是没有实际作用的。
### 猪圈密码
猪圈密码(Pigpen Cipher或称九宫格密码、朱高密码、共济会密码或共济会员密码)，是一种以格子为基础的简单替代式密码。

圣堂武士密码(Templar Cipher)是共济会的“猪圈密码”的一个变种，一直被共济会圣殿骑士用。
### 波利比奥斯方阵密码
波利比奥斯方阵密码（Polybius Square Cipher或称波利比奥斯棋盘）是棋盘密码的一种，是利用波利比奥斯方阵进行加密的密码方式，简单的来说就是把字母排列好，用坐标(行列)的形式表现出来。字母是密文，明文便是字母的坐标。
### 夏多密码
夏多密码(曲折加密)是作者麦克斯韦·格兰特在中篇小说《死亡之链》塑造夏多这一英雄人物中所自创的密码。

![](http://standeblogtc.test.upcdn.net/2/%E7%BD%91%E9%A1%B5%E6%8D%95%E8%8E%B7_22-1-2021_182144_www.tuicool.com.jpeg)

在以上所示的字母表密钥的底部，列有四个附加符号1，2，3，4.他们可以放在密文中的任何地方。每个附加符号指示，如何转动写有密文的纸张，再进行后续的加密或解密操作，直到出现另一个附加符号。可以把每个附加符号中的那根线看作是指示针，它指示了纸张的上端朝上，朝右，朝下，朝左。比如说：如果出现符号3，那么纸张就应该转动180度，使其上端朝下； 符号2表示纸张上端朝右，依次类推。
### 普莱菲尔密码
普莱菲尔密码(Playfair Cipher)是第一种用于实际的双字替换密码，又称为单方密码(Single Cipher)，用双字加密取代了简单代换密码的单字加密，很明显这样使得密文更难破译，因为使用简单替换密码的频率分析基本没有什么作用，虽然频率分析，通常仍然可以进行，但是有25×25=625种可能而不是25种可能，可以分为三个步骤，即编制密码表、整理明文、编写译文。

以明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 和密钥 CULTURE 为例：

![](http://standeblogtc.test.upcdn.net/2/1111111111111111111.png)

![](http://standeblogtc.test.upcdn.net/2/22222222222222222222222.png)

![](http://standeblogtc.test.upcdn.net/2/3333333333333333333333.png)
### 维吉尼亚密码
维吉尼亚密码(Vigenère Cipher)是在单一恺撒密码的基础上扩展出多表代换密码，根据密钥(当密钥长度小于明文长度时可以循环使用)来决定用哪一行的密表来进行替换，以此来对抗字频统计。

![](http://standeblogtc.test.upcdn.net/2/wewewewewewe.jpeg)

明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG

密钥(循环使用，密钥越长相对破解难度越大)： CULTURE

加密过程：如果第一行为明文字母，第一列为密钥字母，那么明文字母'T'列和密钥字母'C'行的交点就是密文字母'V'，以此类推。

密文： VBP JOZGM VCHQE JQR UNGGW QPPK NYI NUKR XFK

有几种密码和维吉尼亚密码相似，格罗斯费尔德密码(Gronsfeld cipher)实际上和维吉尼亚密码相同，除了使用了数字来代替字母以外没有什么区别。数字可以选择一种数列，如斐波那契数列，或者一些其他的伪随机序列。格罗斯费尔德密码密码分析过程和维吉尼亚密码大同小异，不过，自动密钥密码不能使用 卡西斯基算法 (kasiski)来破译，因为自动密钥密码的密钥不重复循环使用，破译自动密钥密码最好的方法的就是从密文不断尝试和猜测其中明文或密钥的一部分。
### 自动密钥密码
自动密钥密码(Autokey Cipher)是多表替换密码，与维吉尼亚密码密切相关，但使用不同的方法生成密钥，通常来说要比维吉尼亚密码更安全。自动密钥密码主要有两种，关键词自动密钥密码和原文自动密钥密码。

以关键词自动密钥为例：

明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG

关键词： CULTURE

自动生成密钥： CULTURE THE QUICK BROWN FOX JUMPS OVER THE

接下来的加密过程和维吉尼亚密码类似，从密表可得：

密文： VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK
### 博福特密码
博福特密码(Beaufort Cipher)，是一种类似于维吉尼亚密码的代换密码，由弗朗西斯·蒲福(Francis Beaufort)发明。它最知名的应用是Hagelin M-209密码机。博福特密码属于对等加密，即加密演算法与解密演算法相同。

加密过程：如果第一行为明文字母，第一列为密文字母，那么沿明文字母'T'列出现密钥字母'C'的行号就是密文字母'J'，以此类推。
### 滚动密钥密码
滚动密钥密码(Running Key Cipher)和维吉尼亚密码有着相同的加密机制，区别是密钥的选取，维吉尼亚使用的密钥简短，而且重复循环使用，与之相反，滚动密钥密码使用很长的密钥，比如引用一本书作为密钥。这样做的目的是不重复循环使用密钥，使密文更难破译，尽管如此，滚动密钥密码还是可以被攻破，因为有关于密钥和明文的统计分析模式可供利用，如果滚动密钥密码使用统计上的随机密钥来源，那么理论上是不可破译的，因为任何可能都可以成为密钥，并且所有的可能性都是相等的。
### Porta密码
Porta密码(Porta Cipher)是一个由意大利那不勒斯的医生Giovanni Battista della Porta发明的多表代换密码，Porta密码具有加密解密过程的是相同的特点。

![](http://standeblogtc.test.upcdn.net/2/ttt5t5t5t5t.png)
### 同音替换密码
同音替换密码(Homophonic Substitution Cipher)是单字母可以被其他几种密文字母同时替换的密码，通常要比标准替换密码破解更加困难，破解标准替换密码最简单的方法就是分析字母出现频率，通常在英语中字母'E'(或'T')出现的频率是最高的，如果我们允许字母'E'可以同时被3种不同字符代替，那么就不能还是以普通字母的频率来分析破解，如果允许可代替字符越多，那么密文就会更难破译。

如果同音替换密码的同音词个数很多，那么破解它难度很大，通常的方法采取类似破解替换密码的"爬山算法"，除了找到一个明文字母映射几个字符之外，我们还需要确定映射了那些字符，可以尝试 2层嵌套"爬山算法" 来破解，外层确定映射的数量，内层确定映射字符。
### 仿射密码
仿射密码(Affine Cipher)是一种单表代换密码，字母表中的每个字母相应的值使用一个简单的数学函数映射到对应的数值，再把对应数值转换成字母。这个公式意味着每个字母加密都会返回一个相同的字母，意义着这种加密方式本质上是一种标准替代密码。因此，它具有所有替代密码的弱点。每一个字母都是通过函数（ax + b）mod m加密，其中B是位移量，为了保证仿射密码的可逆性，a和m需要满足gcd(a , m)=1，一般m为设置为26。
### 培根密码
培根密码(Baconian Cipher)是一种替换密码，每个明文字母被一个由5字符组成的序列替换，最初的加密方式就是由'A'和'B'组成序列替换明文(所以你当然也可以用别的字母)，比如字母'D'替换成"aaabb"。
### ADFGX密码
ADFGX密码(ADFGX Cipher)是结合了改良过的波利比奥斯方阵方格替代密码与单行换位密码的矩阵加密密码，使用了5个合理的密文字母：A，D，F，G，X，这些字母之所以这样选择是因为当转译成摩尔斯电码(ADFGX密码是德国军队在一战发明使用的密码)不易混淆，目的是尽可能减少转译过程的操作错误。

加密矩阵示例：

![](http://standeblogtc.test.upcdn.net/3/233333333.png)

明文： THE QUICK BROWN FOX

结果矩阵加密得到：XF AD DA   AF XD XG GA FG   XA FX DX GX DG   FA DX FF

列移位密钥： how are u

![](http://standeblogtc.test.upcdn.net/3/wwqwq.png)

密文： DXADF AGXF XFFXD FXGGX DGFG AADA ADXXF

ADFGVX密码实际上就是ADFGX密码的扩充升级版，一样具有ADFGX密码相同的特点，加密过程也类似，不同的是密文字母增加了V，使得可以再使用10数字来替换明文。
### 双密码
双密码(Bifid Cipher)结合了波利比奥斯方阵换位密码，并采用分级实现扩散，这里的“双”是指用2个密钥进行加密。双密码是由法国Felix Delastelle发明，除此之外Felix Delastelle还发明了三分密码(Trifid Cipher)，四方密码(Four-Square Cipher)。

有一个与四方密码类似的变种叫两方密码 (Two-Square Cipher，也叫Double Playfair，是之前普莱菲尔密码（另单方密码Single Cipher）的进阶)， 共轭矩阵双密码 (Conjugated Matrix Bifid Cipher)也是双密码的变种。

示例密阵：

![](http://standeblogtc.test.upcdn.net/3/eeeeeeeeeee.png)

明文: THE QUICK BROWN FOX

经过密阵转换：

行: 512 15543 54352 333

列: 421 33525 21115 214

分组:

51215 54354 35233 3

42133 52521 11521 4

合并：

5121542133 5435452521 3523311521 34

在经过密阵转换后密文: WETED TKZNE KYOME X

手工分析破解双密码是有一定难度的，每个字母都是同过3个数字进行非线性代替转换，而且之后还会对字母顺序进行打乱，这样使双密码比一些替换密码和换位密码更难破解。然而,现在是计算机时代，这样的加密方式没有安全性可言，通过模拟退火算法就能快速找到双密码的密阵。
### 三分密码
三分密码(Trifid Cipher)结合换位和替换，三分密码与双密码非常相似，差别之处就是用除了3×3×3的密阵代替5×5密阵。

示例密阵：

![](http://standeblogtc.test.upcdn.net/3/rrrrrrrrrrrrrrrrrrrrrrr.png)

明文: THE QUICK BROWN FOX

经过密阵转换：

![](http://standeblogtc.test.upcdn.net/3/ttttttttttttttttttttttt.png)

T(233)表示T在第一个方阵第三行第三列的位置

分组(分组密钥以5为例)：

![](http://standeblogtc.test.upcdn.net/3/uuuuuuuuuuu.png)

合并：

23131 33132 31132 31223 22232 23221 31233 13311 32113 22 21 32

在经过密阵转换后密文:

![](http://standeblogtc.test.upcdn.net/3/MMMMMMMMMMMMMMMM.png)
### 四方密码
四方密码(Four-Square Cipher)是类似普莱菲尔密码双字母加密密码，这样使加密效果强于其他替换密码，因为频率分析变得更加困难了。

四方密码使用4个预先设置的5×5字母矩阵，每个矩阵包括25个字母，通常字母'j'被融入到'i'中(维基百科上说'q'被忽略，不过这不重要，因为'q'和'j'都是很少出现的字母)，通常左上和右下矩阵式是标准字母排序明文矩阵，右上和左下矩阵是打乱顺序的密钥矩阵。

示例矩阵：

![](http://standeblogtc.test.upcdn.net/3/oooooooooooooooo.png)

明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG

整理明文(分组不够时用'X'填充)： TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX

加密过程：分别在明文矩阵中找到'TH'，分别找到他们在右上矩阵有左下矩阵的交点字母'ES'就是密文，以此类推。

密文： ESZWQAFHGTDKWHRKUENYQOLMQTUNWMBPTGHQ

如果有足够多的密文那么四方密码可以轻易被破解，如果知道了明文和密文推出密钥是很容易的，猜测部分明文是一个有效的方法去破解四方密码，如果一部分明文已知或者可以被猜测出 那么我们首先要确定尽可能多可利用的密钥，然后才可以进行更多的推测或者用其他的方法破译。
### 棋盘密码
棋盘密码（Checkerboard Cipher)是使用一个波利比奥斯方阵和两个密钥作为密阵的替换密码，通常在波利比奥斯方阵中J字母往往被包含在I字母中。
### 跨棋盘密码
跨棋盘密码(Straddle Checkerboard Cipher)是一种替换密码，当这种密码在结合其他加密方式，加密效果会更好。

棋盘示例(选择3和7作为变换)：

![](http://standeblogtc.test.upcdn.net/3/vvvvvvvvvvvvvvv.png)

明文: T H E Q U I C K B R O W N F O X

经过加密棋盘替换得到密文: 72 30 9 34 71 32 4 1 31 35 36 75 74 0 36 77
### 分组摩尔斯替换密码
分组摩尔斯替换密码(Fractionated Morse Cipher)首先把明文转换为莫尔斯电码，不过每个字母之间用x分开，每个单词用xx分开。然后使用密钥生成一个替换密表，这个密表包含所有 . - x 组合的情况(因为不会出现 xxx 的情况，所以一共26种组合)。
### Bazeries密码
Bazeries密码(Bazeries Cipher)是换位密码和替换密码的组合，使用两个波利比奥斯方阵，一个明文字母方阵，使用一个随机的数字(一般小于1000000)的生成一个密钥矩阵同时作为第一轮明文划分分组，比如2333这个数字翻译为英文便是TWO THOUSAND THREE HUNDRED THIRTY THREE,从第一个字母T开始选取不重复的字母，之后再从字母表中按序选取没有出现的字母组成密钥矩阵。
### Digrafid密码
Digrafid密码(Digrafid Cipher)使用两个密钥生成分别生成类似波利比奥斯方阵的3x9方格的密表。，主要有3分组和4分组两类。
### 格朗普雷密码
格朗普雷密码(Grandpré Cipher)是替换密码的一种，一般使用8个8字母的单词横向填充8x8方阵，且第一列为一个单词，并且在方阵中26个字母都必须出现一次以上。
### 比尔密码
比尔密码(Beale ciphers)有三份密码，当然这里说的是已被破解第二份，是一种类似书密码的替换密码。第二密码中，每一个数字代表美国《独立宣言》的文本中的第几个词的首字母，如1代表第1个词的首字母“w”，2代表第2个词首字母“i”。
### 键盘密码
一般用到的键盘密码就是手机键盘和电脑键盘两种，2014 0ctf比赛里Crypto类型中Classic一题就是电脑键盘密码。
## 机械密码
### 恩尼格玛密码
恩尼格玛密码机（德语：Enigma，又译哑谜机，或“谜”式密码机）是一种用于加密与解密文件的密码机。确切地说，恩尼格玛是对二战时期纳粹德国使用的一系列相似的转子机械加解密机器的统称，它包括了许多不同的型号，为密码学对称加密算法的流加密。
## 代码混淆加密
### asp混淆加密
### php混淆加密
### css/js混淆加密
### VBScript.Encode混淆加密
### ppencode
ppencode-Perl把Perl代码转换成只有英文字母的字符串。
### rrencode
rrencode可以把ruby代码全部转换成符号。
### jjencode
jjencode将JS代码转换成只有符号的字符串，类似于rrencode。

aaencode可以将JS代码转换成常用的网络表情，也就是我们说的颜文字js加密。
### JSfuck
JSFuck 可以让你只用 6 个字符 ```[ ]( ) ! + ```来编写 JavaScript 程序。
### jother
jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括： ```! + ( ) [ ] { } ```。只用这些字符就能完成对任意字符串的编码。
### brainfuck
Brainfuck是一种极小化的计算机语言，按照"Turing complete（完整图灵机）"思想设计的语言，它的主要设计思路是：用最小的概念实现一种“简单”的语言，BrainFuck语言只有八种符号，所有的操作都由这八种符号 ```> < + - . , [ ] ```的组合来完成。
# 对称加密算法
对称加密(也叫私钥加密)：指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。

特点是算法公开、计算量小、加密速度快、加密效率高。

不足之处是，交易双方都使用同样钥匙，安全性得不到保证。此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。而与公开密钥加密算法比起来，对称加密算法能够提供加密和认证却缺乏了签名功能，使得使用范围有所缩小。

对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要2个密钥并交换使用，如果企业内用户有n个，则整个企业共需要n×(n-1) 个密钥。对称加密算法的安全性取决于加密密钥的保存情况，如果一个用户使用的密钥被入侵者所获得，入侵者便可以读取该用户密钥加密的所有文档，如果整个企业共用一个加密密钥，那整个企业文档的保密性便无从谈起。

对称加密算法使用置换（对原来字符的重新排列）和替换（用新的字符代替旧的字符）抵御频率分析。
## 密钥导出函数

密钥导出函数（KDF）使用伪随机函数从主密钥导出一个或多子密钥。

·主密钥需要保密

·生成函数越强，其他密钥材料越随机，子密钥越好

·避免长期使用一个主密钥带来的风险
## 典型
### DES
DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来。

# 非对称加密算法
非对称加密(也叫公钥加密)：指加密和解密使用不同密钥的加密算法，也称为公私钥加密。

每个实体有两个不同的密钥即公钥和私钥：

1. 我只需要管理好我的公钥跟私钥就可以。

2. 我需要获取其他人公钥，直接去获取就可以。

3. 我只需要保证我的私钥不被泄露就可以了。

4. N个人相互通讯，只需要2N个密钥（其中只有N个私钥，需要保护）

5. 公钥（public key）是公开的，为其他实体所知

6. 私钥（private key）是保密的，只有所属实体自己知道

7. 密钥分发更容易

**公钥/私钥关系**：

1. 数学上两者紧密关联，互相唯一确定

2. 知道公钥不能推导出私钥

3. 知道公钥和密文不能推导出私钥

4. 使用公钥加密的信息，只能使用私钥进行解密

5. 使用私钥进行加密的信息，只能使用公钥进行解密

6. 加解密时： 使用接收者的公钥进行加密，接收者使用自己的私钥进行解密

比如Alice 发送信息给Bob：

Alice和其他所有人能够简单获取到Bob的公钥

除了Bob以外，所有其他人没有Bob的私钥。

Bob对信息进行解密：

Bob获取使用自己的公钥进行加密的信息后，可以使用自己的私钥进行解密

7.签名时：

Bob对所有人发布信息

Bob使用自身的私钥对信息进行加密（签名）

所有人使用Bob的公钥对信息进行解密（签名验证）
