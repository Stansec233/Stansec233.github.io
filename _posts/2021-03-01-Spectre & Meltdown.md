---
layout: mypost
title: Spectre & Meltdown
categories: [漏洞]
---
”Spectre“（幽灵）漏洞由Google Project Zero的Jann Horn独立发现，Paul Kocher协同Daniel Genkin、Mike Hamburg、Moritz Lipp和Yuval Yarom也合作发现了此问题。2018年1月3日，此漏洞与另一安全漏洞”Meltdown“（熔毁）被一同公布

[腾讯哈勃Spectre&Meltdown检测工具](https://habo.qq.com/tool/detail/meltdown_spectre_scanner)

# “Spectre”漏洞

是可以迫使用户操作系统上的其他程序访问其程序电脑存储器空间中任意位置的一整类的攻击统称

会影响几乎所有1995年以后生产的英特尔CPU、大多数的AMD处理器以及数款智能手机CPU

一开始基于攻击行为类型分类，有两个通用漏洞披露ID，即**CVE-2017-5715（branch target injection，分支目标注入）**和 **CVE-2017-5753（bounds check bypass，边界检查绕过）**

后续有CVE-2018-3693、CVE-2018-3640、CVE-2018-3639等攻击手段变体

由于不同处理器架构对推测运行机制有不同的实现方式，因此无法获得根源上的修复，只能采取见招拆招，而且因机制所致，各种解决方案还有不可预料的性能下降

# “Meltdown”漏洞

即**CVE-2017-5754（Rogue Data Cache Load，恶意数据缓存加载）**

会影响几乎所有1995年以后生产的英特尔CPU

所幸“Meltdown”漏洞可以通过微软补丁完全修复

# 基础准备
要理解这俩漏洞攻击首先要熟悉**内存**的工作方式、**推测执行**和**侧信道攻击**

可以把**内存**想象为一排可以打开的盒子，内存有很多层，拿DRAM来说，它很大但是很慢，CPU读取数据要好一会儿，于是我们就建了好几级的缓存，缓存很小很也很贵，工作原理是当我们试图查询内存中的数据时，会在缓存中复制一份，等到下次再需要时可以直接在缓存中找到

**推测执行（Speculative execution）**机制（也是”Spectre“的变体2——分支目标注入主要利用的机制）可以显著提升CPU的速度与性能，其特点是在CPU实际发出请求之前就预测CPU可能执行的任务。像“探路员”一样，它的目标是通过预先探索CPU的各种可能任务，为整个系统加速，而漏洞就在于通过恶意程序进入系统的“引导员”可以引导“探路员”走固定的路线，随着“探路员”看到在探路过程（因为缓存，CPU运行状态有一点点变化）中看到的一部分信息（包括隐私），即使最后“探路员”发现自己走错了路并回到最初的岔路口，但那时“引导员”很可能已经获得了想到的东西。目前牙膏厂已经设计出一组新的CPU硬件功能，可以与操作系统协作，创造虚拟栅栏来保护其中保存的数据免受这种运用推测执行方法的攻击，即让潜在的“引导员”完全远离计算机的决策进程

**侧信道攻击（side-channel attacks）**其中有一种叫做计时攻击（timing attack），比如说要让计算机验证密码 hunter2 ，简单来说要从第一位从a开始试，电脑检测第一个字符a和密码第一位h不匹配，于是返回验证失败，再实验cdefg......但在这种情况下猜测h时，会发现电脑验证的时间比其他的长了一点，因为电脑发现第一位匹配后，需要检验第二位字符是否匹配，通过验证时间得出密码第一位是h，猜测的时间复杂度与密码长度成线性，此例中侧信道就是验证密码所用运行时间，用物理方法实现算法，时间差会暴露信息

# 攻击过程
集齐了攻击利用的所有元素后：

假设我们有一串内存“盒子”

系统内核将其分成块，分配给不同的程序（考虑云计算的话可能就是划分给不同的虚拟机）

不同的程序所分到的内存块可能是相邻的

此时有一些盒子被“受害者”

操作系统会试图确保一个人程序无法访问属于其他程序的内存区块，不同程序使用的内存块被隔开，其他的程序无法直接读取“受害者”区域的数据

但是可以尝试利用高速的缓存，现在在可以合法访问的正常区域（接近“受害者”区域）里放一个数组A，去访问远超出其范围的第x个元素（下标越界）

通常情况下，CPU会阻止这一操作，扔出一个“非法操作”错误，操作会被强制结束

然鹅我们去在内存划分另一片连续区域叫做“工具”区，特别要求CPU对这段数据不要拷贝至缓存，只保留于内存

假设执行的指令是  `if (地球是平的)：`

一般来说CPU会先无视这个判断，因为它需要等待内存返回“世界是平的”

但是由于有推测执行这个技术，if语句中的东西会被预先执行

写作 `if (地球是平的)：access "工具"区 A[X]`

就可以试图读取工具区第（A[X]）个元素

假如对应数组A的第x个元素在“受害者”的内存中含有我们事先不知道的元素4，但是我们尝试想知道

CPU执行了本不该执行的指令，它需要看一下A[X]的值，此时CPU并未检查A[X]是否已经下标越界

因为CPU认为之后内核总归会验证下标越界，如果越界再强制结束程序

于是推测执行就直接查询了A[X]的值，会发现是4，也就是“工具”区[4]

下一步是攻击的**核心**：

访问“工具”区[4]后，会把其放入高速缓存

最后遍历“工具区”中的每一个元素，会发现第1个有点慢，第2个也是，但是第
5位（“工具”区[4]）突然速度很快，也就是计时攻击

当推测发生错误时，它会回滚寄存器的变化，但是不会回滚高速缓存

CPU推测执行跳过了内存各程序的界限，信息就被泄露了

（“Meltdown”利用的差不多就是上面欺骗CPU这个原理,“Spectre”则是利用分支预测器(Branch Predictor，CPU这个部分负责观察程序执行中的模式，反复看到的函数会被挑出来被重复处理),通过反复命令CPU执行你的指令来训练它将信息转入缓存再计时攻击，有时是命令CPU使用别的函数中位于某个内存地址的数据，与“Meltdown”类似）

![](https://s3.ax1x.com/2021/03/01/6ijBm8.png)

Javascript能破解内存的数据，可以用Javascript写出类似功能的代码，如果写一个Javascript就可以读取内存里的任何资料，漏洞发现者展示过可以用此类方法读取储存的密码

![](https://s3.ax1x.com/2021/03/01/6ijRlq.png)
